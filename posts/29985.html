<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>面试题集锦 | The Blog</title><meta name="author" content="Jason"><meta name="copyright" content="Jason"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="【Java工程师面试宝典】学习说明_互联网校招面试真题面经汇总_牛客网 (nowcoder.com) 一.Java基础面试题1.谈谈你对面向对象的理解​		对比面向过程，是两种不同处理问题的角度，面向过程更注重事情的每一步骤及顺序，面向对象更注重事情有哪些参与者（对象）,以及各自需要做什么。面向过程比较直接高效，面向对象易于复用、扩展和维护。 面向对象的三大基本特征:封装、继承、多态（父类应用指">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题集锦">
<meta property="og:url" content="https://jasonsgong.gitee.io/posts/29985.html">
<meta property="og:site_name" content="The Blog">
<meta property="og:description" content="【Java工程师面试宝典】学习说明_互联网校招面试真题面经汇总_牛客网 (nowcoder.com) 一.Java基础面试题1.谈谈你对面向对象的理解​		对比面向过程，是两种不同处理问题的角度，面向过程更注重事情的每一步骤及顺序，面向对象更注重事情有哪些参与者（对象）,以及各自需要做什么。面向过程比较直接高效，面向对象易于复用、扩展和维护。 面向对象的三大基本特征:封装、继承、多态（父类应用指">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jasonsgong.gitee.io/img/3.jpg">
<meta property="article:published_time" content="2023-09-03T12:43:48.000Z">
<meta property="article:modified_time" content="2023-09-21T02:15:56.000Z">
<meta property="article:author" content="Jason">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jasonsgong.gitee.io/img/3.jpg"><link rel="shortcut icon" href="/img/%E5%9B%BE%E6%A0%87.png"><link rel="canonical" href="https://jasonsgong.gitee.io/posts/29985.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?863f84ff1342665d6b55193272aea7b2";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#008080","bgDark":"#008080","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试题集锦',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-21 10:15:56'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/loading.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">70</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><br/><div class="menus_items"><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://gitee.com/JasonsGong/jasonsgong/pages"><i class="fa-fw fas fa-sync-alt"></i><span> 更新</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.tutorialspoint.com/compile_java8_online.php"><i class="fa-fw fas fa-code"></i><span> 代码</span></a></div><div class="menus_item"><a class="site-page" href="/notice/"><i class="fa-fw far fa-paper-plane"></i><span> 公告</span></a></div><div class="menus_item"><a class="site-page" href="/website/bookmarks.html"><i class="fa-fw fas fa-desktop"></i><span> 网址</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="The Blog"><span class="site-name">The Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://gitee.com/JasonsGong/jasonsgong/pages"><i class="fa-fw fas fa-sync-alt"></i><span> 更新</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.tutorialspoint.com/compile_java8_online.php"><i class="fa-fw fas fa-code"></i><span> 代码</span></a></div><div class="menus_item"><a class="site-page" href="/notice/"><i class="fa-fw far fa-paper-plane"></i><span> 公告</span></a></div><div class="menus_item"><a class="site-page" href="/website/bookmarks.html"><i class="fa-fw fas fa-desktop"></i><span> 网址</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">面试题集锦</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-03T12:43:48.000Z" title="发表于 2023-09-03 20:43:48">2023-09-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-21T02:15:56.000Z" title="更新于 2023-09-21 10:15:56">2023-09-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>41分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面试题集锦"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><p> <a target="_blank" rel="noopener" href="https://www.nowcoder.com/issue/tutorial?tutorialId=94&uuid=ea1986fcff294f6292385703e94689e8">【Java工程师面试宝典】学习说明_互联网校招面试真题面经汇总_牛客网 (nowcoder.com)</a></p>
<h2 id="一-Java基础面试题"><a href="#一-Java基础面试题" class="headerlink" title="一.Java基础面试题"></a>一.Java基础面试题</h2><h3 id="1-谈谈你对面向对象的理解"><a href="#1-谈谈你对面向对象的理解" class="headerlink" title="1.谈谈你对面向对象的理解"></a>1.谈谈你对面向对象的理解</h3><p>​		对比面向过程，是两种不同处理问题的角度，面向过程更注重事情的每一步骤及顺序，面向对象更注重事情有哪些参与者（对象）,以及各自需要做什么。面向过程比较直接高效，面向对象易于复用、扩展和维护。</p>
<p>面向对象的三大基本特征:封装、继承、多态（父类应用指向子类对象）</p>
<h3 id="2-JDK、JRE、JVM之间的区别"><a href="#2-JDK、JRE、JVM之间的区别" class="headerlink" title="2.JDK、JRE、JVM之间的区别"></a>2.JDK、JRE、JVM之间的区别</h3><p>JDK java 开发工具</p>
<p>JRE(Java Runtime Environment   Java 运行环境)</p>
<p>JVM java虚拟机</p>
<p>JDK &#x3D; JRE + 开发工具集（例如 Javac,java 编译工具等)</p>
<p>JRE &#x3D; JVM + Java SE 标准类库（java 核心类库）</p>
<h3 id="3-和equals⽅法的区别"><a href="#3-和equals⽅法的区别" class="headerlink" title="3.&#x3D;&#x3D;和equals⽅法的区别"></a>3.&#x3D;&#x3D;和equals⽅法的区别</h3><p>&#x3D;&#x3D;：如果是基本数据类型，⽐较是值，如果是引⽤类型，⽐较的是引⽤地址<br>equals：具体看各个类重写equals⽅法之后的⽐较逻辑，⽐如String类，虽然是引⽤类型，但是String类中重写了equals⽅法，⽅法内部⽐较的是字符串中的各个字符是否全部相等。</p>
<h3 id="4-String-StringBuffer-StringBuilder的区别"><a href="#4-String-StringBuffer-StringBuilder的区别" class="headerlink" title="4.String,StringBuffer,StringBuilder的区别"></a>4.String,StringBuffer,StringBuilder的区别</h3><p>1.String是不可变的，如果尝试去修改，会新⽣成⼀个字符串对象，StringBuffer和StringBuilder是可变的,修改是在原对象上操作的</p>
<p>2.StringBuffer是线程安全的，StringBuilder是线程不安全的，所以在单线程环境下StringBuilder效率会更⾼</p>
<p>性能: StringBuilder &gt; StringBuffer &gt; String</p>
<h3 id="5-重载和重写的区别"><a href="#5-重载和重写的区别" class="headerlink" title="5.重载和重写的区别"></a>5.重载和重写的区别</h3><p>重载:发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同、方法返回值和访问修饰符可以不同，发生在编译时。</p>
<p>重写:发生在父子类中，方法名，参数列表必须相同，返回值范围小于等于父类，抛出异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类访问修饰符为私有，子类不能重写该方法。</p>
<h3 id="6-接口和抽象类的区别"><a href="#6-接口和抽象类的区别" class="headerlink" title="6.接口和抽象类的区别"></a>6.接口和抽象类的区别</h3><p>1.抽象类可以有实现的方法和抽象的方法</p>
<p>2.抽象类的成员变量可以是各种类型的，接口中的成员变量只能是public static final类型(默认)的</p>
<p>3.抽象类只能继承一个，接口可以实现多个</p>
<p>4.关键字不同，接口的关键字是interface,抽象类的关键字是abstract</p>
<h3 id="7-List和set的区别"><a href="#7-List和set的区别" class="headerlink" title="7.List和set的区别"></a>7.List和set的区别</h3><p>List:有序，按对象进入的顺序保存对象，可重复，允许多个Null元素对象，可以使用iterator取出所有的元素，在逐一遍历，还可以使用get(int index)获取指定下标的元素。</p>
<p>Set:无序，不可重复，最多允许有一个Null元素对象，取元素时只能用iterator接口取得所有元素，再逐一遍历各个元素。</p>
<h3 id="8-hashCode-与equals-之间的关系"><a href="#8-hashCode-与equals-之间的关系" class="headerlink" title="8.hashCode()与equals()之间的关系"></a>8.hashCode()与equals()之间的关系</h3><p>hashCode()的作用是获取哈希码，也称散列码，哈希码的作用是确定该对象在哈希表中的索引位置。</p>
<ul>
<li><p>如果两个对象相等，那么它们的hashCode()值一定相同</p>
</li>
<li><p>如果两个对象hashCode()相等，它们并不一定相等</p>
</li>
</ul>
<h3 id="9-ArrayList和LinkedList的区别"><a href="#9-ArrayList和LinkedList的区别" class="headerlink" title="9.ArrayList和LinkedList的区别"></a>9.ArrayList和LinkedList的区别</h3><p>ArrayList：基于动态数组，连续内存存储，适合下标访问（随机访问）。扩容机制：因为数组长度固定，超出长度存数据时需要新建数组，将老数组的数据拷贝到新数组，然后插入需要加入到数组中的数据。</p>
<p>LinkedList：基于链表，可以存储在分散的内存中，适合做数据插入及删除操作，不适合查询。遍历LinkedList必须使用iterator不能使用for循环，因为for循环体内通过get(i)取得某一元素时都需要对list重新遍历，性能消耗大。</p>
<h3 id="10-HashMap和HashTable的区别？底层实现是什么"><a href="#10-HashMap和HashTable的区别？底层实现是什么" class="headerlink" title="10.HashMap和HashTable的区别？底层实现是什么?"></a>10.HashMap和HashTable的区别？底层实现是什么?</h3><p>区别:</p>
<p>1.HashMap方法没有synchronized修饰，线程非安全，HashTable线程安全</p>
<p>2.HashMap允许key和value为null，而HashTable不允许</p>
<p>底层实现: 数组 + 链表</p>
<h3 id="11-ConcurrentHashMap"><a href="#11-ConcurrentHashMap" class="headerlink" title="11.ConcurrentHashMap"></a>11.ConcurrentHashMap</h3><p>ConcurrentHashMap和HashTable都是线程安全的，但ConcurrentHashMap相比HashTable性能更高</p>
<h3 id="12-如何实现一个IOC容器"><a href="#12-如何实现一个IOC容器" class="headerlink" title="12.如何实现一个IOC容器"></a>12.如何实现一个IOC容器</h3><p>1.配置文件配置包扫描路径</p>
<p>2.递归包扫描获取.class文件</p>
<p>3.反射、确定需要交给IOC管理的类</p>
<p>4.对需要注入的类进行依赖注入</p>
<h3 id="13-什么是字节码？采用字节码的好处是什么？"><a href="#13-什么是字节码？采用字节码的好处是什么？" class="headerlink" title="13.什么是字节码？采用字节码的好处是什么？"></a>13.什么是字节码？采用字节码的好处是什么？</h3><p><strong>什么是字节码？</strong></p>
<p>Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟的机器。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转化为特定系统的机器码执行，在java中，这种供虚拟机理解的代码叫做字节码(即扩展名为.class的文件)。</p>
<p><strong>采用字节码的好处是什么？</strong></p>
<p>Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无需重新编译便可在多种计算机上运行。</p>
<h3 id="14-Java类加载器有哪些"><a href="#14-Java类加载器有哪些" class="headerlink" title="14.Java类加载器有哪些"></a>14.Java类加载器有哪些</h3><p>JDK有三个类加载器:</p>
<ol>
<li>bootstrap ClassLoader是ExClassLoader 的父类加载器，默认负责加载%JAVA_HOME%bin下的jar包和class文件</li>
<li>ExClassLoader是AppClassLoader的父类加载器，负责加载%JAVA_HOME%&#x2F;bin&#x2F;ext文件夹下的jar包和class文件</li>
<li>AppClassLoader是自定义加载器的父类，负责加载classpath下的类文件，系统类加载器，线程上下文加载器</li>
</ol>
<p>自定义加载器的方法: 继承ClassLoader实现自定义加载器</p>
<h3 id="15-双亲委派模型"><a href="#15-双亲委派模型" class="headerlink" title="15.双亲委派模型"></a>15.双亲委派模型</h3><p><strong>双亲委派模型的执行流程是这样的：</strong> </p>
<p>1、当加载一个类时，会先从应用程序类加载器的缓存里查找相应的类，如果能找到就返回对象，如果找不到就执行下面流程；</p>
<p>2、在扩展加载器缓存中查找相应的类，如果能找到就返回对象，如果找不到就继续下面流程；</p>
<p>3、在启动类加载器中查询相应的类，如果找到就返回对象，如果找不到就继续下面流程；</p>
<p>4、在扩展加载器中查找并加载类，如果能找到就返回对象，并将对象加入到缓存中，如果找不到就继续下面流程；</p>
<p>5、在应用程序类加载器中查找并加载类，如果能找到就返回对象，并将对象加入到缓存中，如果找不到就返回 ClassNotFound 异常。</p>
<p><strong>加载流程如下图所示：</strong></p>
<p><img src="/pictures/image-20230904161407239.png" alt="image-20230904161407239"></p>
<p>一般“双亲”指的是“父亲”和“母亲”，而在这里“双亲”指的是类加载类先向上找，再向下找的流程就叫做双亲委派模型。</p>
<p><strong>双亲委派模型的好处</strong></p>
<ol>
<li>主要是为了安全性，避免用户自己编写的类动他替换java的一些核心类，比如String</li>
<li>同时避免了类的重复加载，因为jvm中区分不同类，不仅仅是根据类名，相同的class文件被不同的ClassLoader加载就是不同的两个类</li>
</ol>
<h3 id="16-Java中的异常体系"><a href="#16-Java中的异常体系" class="headerlink" title="16.Java中的异常体系"></a>16.Java中的异常体系</h3><ol>
<li>Java中所有异常都来自顶级父类Throwable</li>
<li>Throwable下面有两个子类Exception和Error</li>
<li>Error是程序无法处理的错误，一旦出现这个错误，程序将被迫停止运行；Exception不会导致程序停止</li>
<li>Exception有分为两个部分RunTimeException运行时异常和CheckedException检查异常</li>
<li>RunTimeException常常发生在程序运行过程中，会导致程序当前线程执行失败。CheckedException常常发生在程序编译过程中，会导致程序编译不通过。</li>
</ol>
<h3 id="17-GC如何判断对象可以被回收"><a href="#17-GC如何判断对象可以被回收" class="headerlink" title="17.GC如何判断对象可以被回收"></a>17.GC如何判断对象可以被回收</h3><ul>
<li>引用计数法：每一个对象有一个引用计数属性，新增一个引用计数加1，引用释放减1，计数为0时可以回收。（java中没有使用这个方法，原因：可能会出现A引用了B，B又引用了A，这时就算他们都不再使用了，但是因为他们互相引用，计数器&#x3D;1永远无法被回收）</li>
<li>可达性分析法：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，那么虚拟机就可以判断是可回收对象。</li>
</ul>
<h3 id="18-线程的生命周期，线程有哪些状态"><a href="#18-线程的生命周期，线程有哪些状态" class="headerlink" title="18.线程的生命周期，线程有哪些状态"></a>18.线程的生命周期，线程有哪些状态</h3><p>线程通常有五种状态：创建、就绪、运行、阻塞、死亡状态</p>
<p>阻塞又分为三种情况：等待阻塞、同步阻塞、其他阻塞</p>
<ol>
<li>新建状态：新创建了一个线程对象</li>
<li>就绪状态：线程对象创建后，其他线程调用了该对象的start()方法。该线程位于可运行线程池中，变得可运行，等待获取CPU的使用权</li>
<li>运行状态：就绪状态的线程获取了CPU，执行了程序代码</li>
<li>阻塞状态：阻塞状态是线程因为某种原因放弃了CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态</li>
<li>死亡状态：线程执行完了或者因为异常退出了run()方法，该线程结束生命周期</li>
</ol>
<h3 id="19-sleep-wait-join-yield-的区别"><a href="#19-sleep-wait-join-yield-的区别" class="headerlink" title="19.sleep(),wait(),join(),yield()的区别"></a>19.sleep(),wait(),join(),yield()的区别</h3><p><strong>sleep(),wait()的区别</strong></p>
<ol>
<li>sleep()是Thread类的静态本地方法，wait()是Object类的本地方法</li>
<li>sleep()不会释放锁（把锁带着进入冻结状态），wait会释放锁</li>
<li>sleep方法不依赖于同步器synchronized，但是wait需要依赖synchronized关键字</li>
<li>sleep不需要被唤醒（休眠之后退出阻塞），但是wait需要（不指定时间需要被别人中断）</li>
<li>sleep一般用于当前线程休眠，或者轮循暂停操作，wait则用于多线程之间的通信</li>
<li>sleep会让出cpu执行时间且强制上下文切换，而wait则不一定，wait后可能还是有机会重新竞争到锁继续执行</li>
</ol>
<p><strong>yield()执行后线程直接进入就绪状态，马上释放了cpu，但是依然保留了cpu的执行资格，所有有可能cpu下次进行线程调度还会让这个线程取到执行权</strong></p>
<p><strong>join()执行后线程进入阻塞状态，例如在线程B中调用了A的join()，那线程B会进入到阻塞队列，直到线程A结束或者中断线程</strong></p>
<h3 id="20-说说你对线程安全的理解"><a href="#20-说说你对线程安全的理解" class="headerlink" title="20.说说你对线程安全的理解"></a>20.说说你对线程安全的理解</h3><p>线程安全讲的不是线程安全，应该是<strong>内存安全</strong>，<strong>堆是共享内存，可以被所有线程访问</strong></p>
<p><strong>线程安全的定义</strong>：当多个线程访问一个对象的时候，如果不用进行<strong>额外的同步控制或者其他的协调操作</strong>，调用这个对象的行为都可以获得<strong>正确的结果</strong>，我们就说这个线程数是安全的。</p>
<p><strong>产生线程安全问题的原因:</strong> 在每个进程的内存空间中都会有一块特殊的公共区域，通常称为堆（内存）。进程内所有线程都可以访问到该区域，这就是造成问题的潜在原因。</p>
<h3 id="21-说说你对守护线程的理解"><a href="#21-说说你对守护线程的理解" class="headerlink" title="21.说说你对守护线程的理解"></a>21.说说你对守护线程的理解</h3><p><strong>守护线程</strong>：为非守护线程（用户线程）提供服务的线程，任何一个守护线程都是整个jvm中所有非守护线程的守护线程。</p>
<p><strong>守护线程的作用：</strong></p>
<p>举例：GC垃圾回收机制，就是一个经典的守护线程，当我们的程序不再有任何运行的Thread，程序就不会再产生垃圾，垃圾回收器也就没事可做，所以当垃圾回收线程是jvm上仅剩的线程时，垃圾回收线程会自动离开，它始终再低级别的状态中运行，用于实时监控和管理系统中的可回收资源。</p>
<p><strong>应用场景:</strong></p>
<ol>
<li>为其他的线程提供服务支持情况</li>
<li>或者在任何情况下，程序结束时，这个线程必须正常的且立刻关闭，就可以作为守护线程来使用</li>
</ol>
<h3 id="22-ThreadLocal的原理和使用场景"><a href="#22-ThreadLocal的原理和使用场景" class="headerlink" title="22.ThreadLocal的原理和使用场景"></a>22.ThreadLocal的原理和使用场景</h3><p>同一个线程中通过ThreadLocal存进去的数据，在任何位置取出来是一致的</p>
<p><strong>原理</strong></p>
<p>每一个Thread对象均含有一个ThreadLocalMap类型的成员变量threadLocals,它存储<strong>本线程</strong>中所有ThreadLocal对象及对应的值。</p>
<p>当执行set()方法时，ThreadLocal首先会获取当前线程对象，然后获取当前线程的ThreadLocalMap对象。再以当前ThreadLocal对象为key，获取对应的value。</p>
<p>get方法的执行过程类似。ThreadLocal首先会获取当前线程对象，然后获取当前线程的ThreadLocalMap对象。再以当前ThreadLocal对象为key，获取对应的value。</p>
<p>由于每一条线程均含有各自<strong>私有</strong>的ThreadLocalMap容器，这些容器相互独立，互不影响，因此不会存在线程安全性问题，从而无需使用同步机制来保证多条线程访问容器的互斥性。</p>
<p><strong>使用场景</strong></p>
<ol>
<li>在进行对象的跨层传递的时候，使用ThreadLocal可以避免多次传递，打破层次间的约束</li>
<li>线程间数据隔离</li>
<li>进行事务操作，用于存储事务信息</li>
<li>数据库连接，Session会话管理</li>
</ol>
<h3 id="23-ThreadLocal内存泄漏原因，怎么避免"><a href="#23-ThreadLocal内存泄漏原因，怎么避免" class="headerlink" title="23.ThreadLocal内存泄漏原因，怎么避免"></a>23.ThreadLocal内存泄漏原因，怎么避免</h3><p><strong>内存泄漏</strong>:不会使用的对象或者变量占用的内存不能被回收，就是内存泄漏(内存泄漏为程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏的危害可以忽略，但内存泄漏堆积后果很严重，无论多少内存，迟早会被占光，导致OOM。)</p>
<p>强引用：使用最普遍的引用（通过new），一个对象具有强应用，不会被垃圾回收器回收，即使是内存不足。我们想要取消强引用，可以显示的将引用赋值为null，jvm在合适的时间就会回收该对象。</p>
<p><strong>ThreadLocal内存泄漏的根源</strong></p>
<p>由于ThreadLocalMap的生命周期和Thread一样长，如果没有手动删除对应key就会导致内存泄漏</p>
<p><strong>怎么避免</strong></p>
<ol>
<li>每次使用ThreadLocal都调用它的remove()方法清除数据</li>
<li>将ThreadLocal变量定义成private static,这样就一直村子ThreadLocal的强应用，也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉。</li>
</ol>
<h3 id="24-产生内存泄漏的原因有哪些"><a href="#24-产生内存泄漏的原因有哪些" class="headerlink" title="24.产生内存泄漏的原因有哪些"></a>24.产生内存泄漏的原因有哪些</h3><ol>
<li>资源未关闭或释放导致内存泄露(io资源，数据库的连接)</li>
<li>使用 ThreadLocal 造成内存泄露</li>
<li>静态集合类引起内存泄漏，如HashMap、LinkedList等等。如果这些容器为静态的，那么它们的生命周期与程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。生命周期长的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。</li>
<li>重写了 finalize() 的类，如果 finalize() 方法重写的不合理或 finalizer 队列无法跟上 Java 垃圾回收器的速度，那么迟早，应用程序会出现 OutOfMemoryError 异常</li>
</ol>
<h3 id="25-并发、并行、串行的区别"><a href="#25-并发、并行、串行的区别" class="headerlink" title="25.并发、并行、串行的区别"></a>25.并发、并行、串行的区别</h3><p>串行在时间上不可能发生重叠，前一个任务没有搞定，下一个任务只能等</p>
<p>并行在时间上是重叠的，两个任务在同一时刻互不干扰的同时执行</p>
<p>并发允许两个任务彼此干扰，同一时间点，只有一个任务运行，交替执行</p>
<h3 id="26-并发的三大特性"><a href="#26-并发的三大特性" class="headerlink" title="26.并发的三大特性"></a>26.并发的三大特性</h3><ul>
<li>原子性：是指在在一个操作中，CPU不可以在中途暂停然后再调度，即不被中断操作，要不全部执行完成，要不都不执行。</li>
<li>可见性：当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他的线程能够立即看到修改的值。</li>
<li>有序性：虚拟机再进行代码编译的时，对于那些改变顺序之后不会对最终的结果造成影响的代码，虚拟机不一定会按照我们写的代码的顺序来执行，有可能将它们重排序。</li>
</ul>
<h3 id="27-为什么用线程池？解释线程池参数？"><a href="#27-为什么用线程池？解释线程池参数？" class="headerlink" title="27.为什么用线程池？解释线程池参数？"></a>27.为什么用线程池？解释线程池参数？</h3><p><strong>为什么</strong></p>
<ol>
<li>降低资源的消耗；提高线程的利用率，降低创建和销毁现成的消耗</li>
<li>提高响应速度，任务来了，直接有线程可用执行，不是创建线程之后再执行</li>
<li>提高线程的可管理性；线程是稀缺资源，使用线程池可以统一分配调优监控</li>
</ol>
<p><strong>线程池参数</strong></p>
<ul>
<li><code>corePoolSize</code>代表核心线程数，也就是正常情况下创建工作的线程数，这些线程创建之后不会消除，而是一种常驻线程。</li>
<li><code>maxnumPoolSize</code>代表最大线程数，它与核心线程数相对应，表示最大允许被创建的线程数，比如当前任务较多，将核心线程数都用完了，还无法满足要求时，此时就会创建新的线程，但是线程池总数不会超过最大线程数</li>
<li><code>keepAliveTime</code>空闲线程存活时间,当一个可被回收的线程的空闲时间大于keepAliveTime，就会被回收; unit：keepAliveTime的时间单位</li>
<li><code>workQueue</code>工作队列,存放待执行任务的队列：当提交的任务数超过核心线程数大小后，再提交的任务就存放在工作队列，任务调度时再从队列中取出任务。它仅仅用来存放被execute()方法提交的Runnable任务。工作队列实现了BlockingQueue接口。</li>
<li><code>threadFactory</code>线程工厂,创建线程的工厂，可以设定线程名、线程编号等。</li>
<li><code>handler</code>拒绝策略,当线程池线程数已满，并且工作队列达到限制，新提交的任务使用拒绝策略处理。可以自定义拒绝策略，拒绝策略需实现RejectedExecutionHandler接口。</li>
</ul>
<h3 id="28-简述线程池的处理流程"><a href="#28-简述线程池的处理流程" class="headerlink" title="28.简述线程池的处理流程"></a>28.简述线程池的处理流程</h3><p><img src="/pictures/image-20230905204135018.png" alt="image-20230905204135018"></p>
<h3 id="29-线程池中阻塞队列的作用？为什么是先添加队列而不是先创建最大线程？"><a href="#29-线程池中阻塞队列的作用？为什么是先添加队列而不是先创建最大线程？" class="headerlink" title="29.线程池中阻塞队列的作用？为什么是先添加队列而不是先创建最大线程？"></a>29.线程池中阻塞队列的作用？为什么是先添加队列而不是先创建最大线程？</h3><p><strong>线程池中阻塞队列的作用？</strong></p>
<p>1、一般的队列只能保证作为一个有限长度的缓冲区，如果超出了缓冲长度，就无法保留当前的任务了，阻塞队列通过阻塞可以保留住当前想要继续入队的任务。</p>
<p>2、阻塞队列可以保证任务队列中没有任务时阻塞获取任务的线程，使得线程进入wait状态，释放cpu资源。</p>
<p>3、阻塞队列自带阻塞和唤醒的功能，不需要额外处理，无任务执行时，线程池利用阻塞队列的take方法挂起，从而维持核心线程的存活，不至于一直占着cpu资源。</p>
<p><strong>为什么是先添加队列而不是先创建最大线程？</strong></p>
<p>在创建新线程的时候。是要获取全局锁的，这个时候其它就得阻塞，影响了整体效率。</p>
<p>就好比一个企业里面有10个（core）正式工的名额，最多招10个正式工，要是任务超过正式工人数，（task &gt; core）的情况下，工厂领导（线程池）不是首先扩招工人，还是这10个人，但是任务会稍微的积压一下，即先放到队列去（代价低），10个正式工慢慢干，迟早会干完的，要是任务还在继续增加，超过正式工的加班忍耐极限了（队列满了），就得招外包帮忙了（注意是临时工），要是正式工加上外包还是不能完成任务，那新来的任务就会被领导拒绝了（线程池的拒绝策略）。</p>
<h3 id="30-线程池中线程复用原理"><a href="#30-线程池中线程复用原理" class="headerlink" title="30.线程池中线程复用原理"></a>30.线程池中线程复用原理</h3><p>线程池将线程和任务解耦，线程是线程，任务是任务，摆脱了之前通过Thread创建线程时的一个线程必须对应一个任务的限制。</p>
<p>在线程池中，同一个线程可以从阻塞队列中不断获取新任务来执行，其核心原理在于线程池对Thread进行了封装，并不是每次执行都会调用Thread.start()来创建新线程，而是让每个线程去执行一个“循环任务”，在这个“循环任务”中不停检查是否有任务需要被执行，如果有则执行，也就是调用任务中的run方法，将run方法当成一个普通的方法执行，通过这种方式只使用固定的线程就将所有任务的run方法串联起来。</p>
<h3 id="31-Spring是什么"><a href="#31-Spring是什么" class="headerlink" title="31.Spring是什么"></a>31.Spring是什么</h3><p>轻量级的开源的j2EE框架。他是一个容器框架，用来装javabean（java对象），中间层框架（万能胶）可以起一个连接作用，比如说把struts和hibernate粘合在一起运用，可以让我们的企业开发更快、更简洁</p>
<p>Spring是一个轻量级的控制反转(ioc)和面向切面（aop）的容器框架</p>
<ul>
<li>从大小与开销两方面而言Spring都是轻量级的</li>
<li>通过控制反转(ioc)的技术达到松耦合的目的</li>
<li>提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务进行内聚的开发</li>
<li>包含并管理应用对象（bean）的配置和生命周期，这个意义上是一个容器</li>
<li>将简单的组件配置、组合成复杂的应用，这个意义上是一个框架</li>
</ul>
<h3 id="32-谈谈你对AOP的理解"><a href="#32-谈谈你对AOP的理解" class="headerlink" title="32.谈谈你对AOP的理解"></a>32.谈谈你对AOP的理解</h3><p>系统是由许多不同的组件所组成的，每一个组件各负责一块特定的功能。除了实现自身的核心功能之外，这些组件还经常承担着额外的职责。例如日志、事务管理和安全这样的服务经常融入到自身具有核心业务逻辑的组件中去。这些系统服务经常被称为横切关注点，因为他们会跨域系统的多个组件。</p>
<p>当我们需要将分散的对象引入公共行为的时候，OOP则显得无能为力，也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能</p>
<p>AOP：将程序中的交叉业务逻辑（比如安全、日志、事务），封装成一个切面。然后注入到目标对象（具体业务逻辑）中去。AOP可以对某个对象或者某些功能进行增强，比如对象中的方法进行增强，可以在执行某个方法之前额外做一些事情，在某个方法执行之后额外做一些事情。</p>
<h3 id="33-谈谈你对IOC的理解"><a href="#33-谈谈你对IOC的理解" class="headerlink" title="33.谈谈你对IOC的理解"></a>33.谈谈你对IOC的理解</h3><p>容器概念、控制反转、依赖注入三方面理解</p>
<p><strong>容器概念</strong></p>
<p>ioc容器：实际上就是个map（key、value），里面存的就是各种对象（在xml里配置bean节点、@Repository、@Service、@Controller），在项目启动的时候会读取配置文件路面的bean节点。</p>
<p><strong>控制反转</strong></p>
<p>在没有引入ioc容器之前，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。</p>
<p>引入ioc容器之后，对象A和对象B之间失去了直接联系。当对象A运行到需要对象B的时候，ioc容器会主动创建一个对象B注入到对象A需要的地方。</p>
<p>通过前后的对比，不难看出来：对象A获得依赖对象B的过程，由主动行为变成了被动行为，控制权颠倒过来了，这就是控制反转这个名称的由来。</p>
<p><strong>依赖注入</strong></p>
<p>“获得依赖对象的过程被反转了”。控制器反转之后，获得依赖对象的过程由自身管理变为了由IOC容器主动注入。依赖注入是实现IOC的方法，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。</p>
<h3 id="34-BeanFactory和ApplicationContext有什么区别？"><a href="#34-BeanFactory和ApplicationContext有什么区别？" class="headerlink" title="34.BeanFactory和ApplicationContext有什么区别？"></a>34.BeanFactory和ApplicationContext有什么区别？</h3><p>ApplicationContext是BeanFactory的子接口</p>
<p>ApplicationContext提供了更完整的功能</p>
<p>1、继承了MessageSource,因此支持国际化</p>
<p>2、统一资源文件的访问方式</p>
<p>3、提供在监听器中注册bean的事件</p>
<p>4、同时加载多个配置文件</p>
<p>5、载入多个（有继承关系）上下文，使得每一个上下文都专注于一个特定的层次，比如应用的web层</p>
<h3 id="35-深拷贝和浅拷贝"><a href="#35-深拷贝和浅拷贝" class="headerlink" title="35.深拷贝和浅拷贝"></a>35.深拷贝和浅拷贝</h3><p>深拷贝和浅拷贝就是指对象的拷贝，一个对象中存在两种类型的属性，一种是基本数据类型，一种是实列对象的引用</p>
<ul>
<li>浅拷贝是指，只会拷贝基本数据类型的值，以及实例对象的引用地址，并不会复制一份引用地址所指向的对象，也就是浅拷贝出来的对象，内部的类属性指向的是一个对象</li>
<li>深拷贝是指，既会拷贝基本数据类型的值，也会针对实例对象的引用地址所指向的对象进行复制，深拷贝出来的对象，内部的类执行指向的不是同一个对象</li>
</ul>
<p>举例:A对象中有一个user属性，A1拷贝A对象，两个user指向同一个对象的话，就是浅拷贝，反之是深拷贝</p>
<h3 id="36-TCP和UDP有什么区别？TCP为什么是三次握手，而不是两次？"><a href="#36-TCP和UDP有什么区别？TCP为什么是三次握手，而不是两次？" class="headerlink" title="36.TCP和UDP有什么区别？TCP为什么是三次握手，而不是两次？"></a>36.TCP和UDP有什么区别？TCP为什么是三次握手，而不是两次？</h3><p><strong>TCP</strong> （Transfer Control Protocol）是一种面向连接的、可靠的、传输层通信协议</p>
<ul>
<li>面向连接的，点对点的通信，高可靠，效率比较低、占用系统的资源比较多（类似于打电话）</li>
</ul>
<p><strong>UDP</strong>  (User Datagram Protocal) 是一种无连接、不可靠的、传输层通信协议</p>
<ul>
<li>不需要连接、发送方不管接收方有没有准备好，直接发消息；可以进行广播发送的；传输不可靠，有可能会丢失消息；效率比较高；协议比较简单，占用的系统资源少（类似于广播）</li>
</ul>
<p><strong>TCP为什么是三次握手，而不是两次？</strong></p>
<p>如果是两次握手，可能会造成连接资源浪费的问题</p>
<h3 id="37-JVM中有哪些垃圾回收算法？"><a href="#37-JVM中有哪些垃圾回收算法？" class="headerlink" title="37.JVM中有哪些垃圾回收算法？"></a>37.JVM中有哪些垃圾回收算法？</h3><p>MarkSweep标记清除算法</p>
<p>Copying拷贝算法</p>
<p>MarkCompack标记压缩算法</p>
<h2 id="二-框架篇相关面试题"><a href="#二-框架篇相关面试题" class="headerlink" title="二.框架篇相关面试题"></a>二.框架篇相关面试题</h2><h3 id="1-Spring-Bean的生命周期"><a href="#1-Spring-Bean的生命周期" class="headerlink" title="1.Spring Bean的生命周期"></a>1.Spring Bean的生命周期</h3><p><strong>1.创建前准备阶段</strong></p>
<p>这个阶段主要是在开始Bean加载之前，从Spring上下文和相关配置中解析并查找Bean有关的配置内容，比如<code>init-method</code>-容器在初始化bean时调用的方法、<code>destory-method</code>，容器在销毁Bean时调用的方法。以及，BeanFactoryPostProcessor这类的bean加载过程中的前置和后置处理。这些类或者配置其实是Spring提供给开发者，用来实现Bean加载过程中的扩展机制，在很多和Spring集成的中间件经常使用，比如Dubbo。</p>
<p><strong>2.创建实例阶段</strong></p>
<p>这个阶段主要是通过反射来创建Bean的实例对象，并且扫描和解析Bean声明的一些属性。</p>
<p><strong>3.依赖注入阶段</strong></p>
<p>在这个阶段，会检测被实例化的Bean是否存在其他依赖，如果存在其他依赖，就需要对这些被依赖Bean进行注入。比如通过<code>@Autowired</code>、@Setter等依赖注入的配置。在这个阶段还会触发一些扩展的调用，比如常见的扩展类：BeanPostProcessors（用来实现Bean初始化前后的回调）、InitializingBean类（这个类有一个afterPropertiesSet()方法，给属性赋值）、还有BeanFactoryAware等等。</p>
<p><strong>4.容器缓存阶段</strong></p>
<p>容器缓存阶段主要是把Bean保存到IoC容器中缓存起来，到了这个阶段，Bean就可以被开发者使用了。这个阶段涉及到的操作，常见的有<code>init-method</code>这个属性配置的方法，会在这个阶段调用。比如BeanPostProcessors方法中的后置处理器方法postProcessAfterInitialization，也是在这个阶段触发的。</p>
<p><strong>5.销毁实例阶段</strong></p>
<p>这个阶段，是完成Spring应用上下文关闭时，将销毁Spring上下文中所有的Bean。如果Bean实现了DisposableBean接口，或者配置了<code>destory-method</code>属 性，将会在这个阶段被调用。</p>
<h3 id="2-Spring框架中的单例Bean是线程安全的吗？"><a href="#2-Spring框架中的单例Bean是线程安全的吗？" class="headerlink" title="2.Spring框架中的单例Bean是线程安全的吗？"></a>2.Spring框架中的单例Bean是线程安全的吗？</h3><p>不是线程安全的！</p>
<p>Sping中Bean默认是单例模式的，框架中并没有对Bean进行多线程的封装处理。</p>
<p>线程安全这个问题，要从单例与原型Bean分别进行说明。</p>
<p><strong>「原型Bean」</strong>对于原型Bean,每次创建一个新对象，也就是线程之间并不存在Bean共享，自然是不会有线程安全的问题。</p>
<p><strong>「单例Bean」</strong>对于单例Bean,所有线程都共享一个单例实例Bean,因此是存在资源的竞争。</p>
<p>如果单例Bean,是一个无状态Bean，也就是线程中的操作不会对Bean的成员执行<strong>「查询」</strong>以外的操作，那么这个单例Bean是线程安全的。比如Spring mvc 的 Controller、Service、Dao等，这些Bean大多是无状态的，只关注于方法本身。</p>
<h3 id="3-Spring-Bean作用域"><a href="#3-Spring-Bean作用域" class="headerlink" title="3.Spring Bean作用域"></a>3.Spring Bean作用域</h3><p>Spring 的 bean 作用域（scope）类型有5种：</p>
<p>1、singleton:单例，默认作用域。</p>
<p>2、prototype:原型，每次创建一个新对象。</p>
<p>3、request:请求，每次Http请求创建一个新对象，适用于WebApplicationContext环境下。</p>
<p>4、session:会话，同一个会话共享一个实例，不同会话使用不用的实例。</p>
<p>5、global-session:全局会话，所有会话共享一个实例。</p>
<h3 id="4-Spring框架中用到了哪些设计模式？"><a href="#4-Spring框架中用到了哪些设计模式？" class="headerlink" title="4.Spring框架中用到了哪些设计模式？"></a>4.Spring框架中用到了哪些设计模式？</h3><ol>
<li>简单工厂：由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。Spring中的BeanFactory就是简单工厂模式的体现，根据传入的一个唯一的标识来获得Bean对象，但是否在传入参数后创建还是传入参数前创建这个要根据具体情况来定。</li>
<li>工厂方法：实现了FactoryBean接口的bean是一类叫做factory的bean.其特点是，spring会在使用getBean()调用获得该bean时，会自动调用该bean的getObject()方法，所以返回的不是factory这个bean,而是这个bean.getObject()方法的返回值。</li>
<li>单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。spring对单例的实现：spring中的单例模式完成了后半句话，即提供了全局访问点BeanFactory，但没有从构造器级别去控制单例，这时因为spring管理的是任意的java对象。</li>
<li>适配器模式：spring中定义了一个适配接口，使得每一种Controller有一种对应的适配器实现类，让适配器代替controller执行响应的方法。这样扩展controller时，只需要增加一个适配类就完成了springMvc的扩展了。</li>
<li>装饰器模式：动态地给一个对象增加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。spring中用到的装饰器模式在类名上有两种表现：一是类名中含有wrapper，另一种时类名中含有Decorator.</li>
<li>动态代理：切面在应用运行的时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面的。  织入：把切面应用到目标对象并创建新代理对象的过程。</li>
<li>观察者模式：Spring的事件驱动模型使用的是观察者模式，spring中observer模式常用的地方是listener的实现。</li>
<li>策略模式:spring框架的资源访问Resource接口。该接口提供了更强的资源访问能力，spring框架本身大量使用了Resource接口来访问底层资源。</li>
</ol>
<h3 id="5-spring中事务实现方和原理式以及隔离级别？"><a href="#5-spring中事务实现方和原理式以及隔离级别？" class="headerlink" title="5.spring中事务实现方和原理式以及隔离级别？"></a>5.spring中事务实现方和原理式以及隔离级别？</h3><p><strong>实现方式</strong></p>
<p>在使用Spring框架时，可以有两种使用事务的方式，一种是编程式，一种是申明式的，@Transactional注解就是申明式的。</p>
<p>首先，事务这个概念是数据库层面的，Spring只是基于数据库中的事务进行了扩展，以及提供了一些能让程序员更加方便操作事务的方式。比如我们可以通过在某个方法上增加@Transactional注解，就可以开启事务，这个方法中所有的sql都会在一个事务中执行，统一成功失败。</p>
<p><strong>原理</strong></p>
<p>在一个方法上加了@Transactional注解后，Spring会基于这个类生成一个代理对象，会将这个代理对象作为bean,当在使用这个代理对象的方法时，如果这个方法存在@Transactional注解，那么代理逻辑会先把事务的自动提价设置为false,然后再去执行原本的业务逻辑方法，如果执行业务逻辑方法没有异常，那么代理逻辑中就会将事务进行提交，如果执行业务逻辑方法出现了异常，那么则会将事务进行回滚。当然，针对哪些异常回滚事务是可以配置的，可以利用@Transactional注解中的rollbackFor属性进行配置，默认情况下会对RuntimeException和Error进行回滚。</p>
<p><strong>隔离级别</strong></p>
<p>spring的事务隔离级别就是数据库的隔离级别外加一个默认级别</p>
<ol>
<li>read uncommitted(未提交读)</li>
<li>read committed(提交读、不可重复读)</li>
<li>repeatable read (可重复读)</li>
<li>serializable(可串行化)</li>
</ol>
<p>注：数据库设置的隔离级别会被spring的配置覆盖</p>
<h3 id="6-Spring事务传播机制"><a href="#6-Spring事务传播机制" class="headerlink" title="6.Spring事务传播机制"></a>6.Spring事务传播机制</h3><p>多个事务方法相互调用的时，事务是如何在这些方法间传播</p>
<p>方法A是一个事务的方法，方法A执行过程中调用了方法B，那么方法B有无事务以及方法B对事务的要求不同都会对方法A的事务具体执行造成影响，同时方法A的事务对方法B的事务执行也有影响，这种影响具体是什么就由两个方法所定义的事务传播类型所决定。</p>
<p><strong>REQUIRED</strong>(Spring默认的事务传播类型)如果当前没有事务，则自己创建一个事务，如果当前存在事务，则加入这个事务</p>
<p><strong>SUPPORTS</strong>:当前存在事务，则加入当前事务，如果当前没有事务，就以非事务方法执行</p>
<p><strong>MANDATORY</strong>:当前存在事务，则加入当前事务，如果当前的事务不存在，则抛出异常</p>
<p><strong>REQUIRES_NEW</strong>:创建一个新事务，如果存在当前事务，则挂起该事务</p>
<p><strong>NOT_SUPPORTED</strong>：以非事务方式执行，如果当前存在事务，则挂起当前事务</p>
<p><strong>NEVER</strong>:不使用事务，如果当前事务存在，则抛出异常</p>
<p><strong>NESTED</strong>:如果当前事务存在，则在嵌套事务中执行，否则REQUIRED的操作一样（开启一个事务）</p>
<h3 id="7-Spring事务什么时候会失效？"><a href="#7-Spring事务什么时候会失效？" class="headerlink" title="7.Spring事务什么时候会失效？"></a>7.Spring事务什么时候会失效？</h3><p>Spring事务原理是AOP，进行了切面增强，那么失效的根本原因是这个AOP不起作用了，常见情况有如下几种</p>
<ol>
<li>发生自调用，类里面使用this调用本类的方法，此时这个this对象不是代理类，而是UserService对象本身</li>
<li>方法不是public的,非要在非public上使用事务，可以开启Aspectj代理模式</li>
<li>数据库不支持事务，例如使用的MyISAM存储引擎</li>
<li>没有被spring管理</li>
<li>异常被吃掉，事务不会回滚（或者抛出的异常没有定义，默认为RuntimeException）</li>
</ol>
<h3 id="8-什么是bean的自动装配，有哪些方式？"><a href="#8-什么是bean的自动装配，有哪些方式？" class="headerlink" title="8.什么是bean的自动装配，有哪些方式？"></a>8.什么是bean的自动装配，有哪些方式？</h3><p>autowire属性有五种装配的方式</p>
<ul>
<li>no – 缺省情况下，自动配置是通过“ref”属性手动设定</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--手动装配：以value或ref的方式明确指定属性值都是手动装配。 需要通过‘ref’属性来连接bean--&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>byName-根据bean的属性名称进行自动装配</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Cutomer的属性名称是person，Spring会将bean id为person的bean通过setter方法进行自动装配--&gt;</span></span><br><span class="line">&lt; bean id=“cutomer” class=“com.xxx.xxx.Cutomer” autowire=“byName”/&gt;</span><br><span class="line">&lt; bean id=“person” class=“com.xxx.xxx.Person”/&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>byType-根据bean的类型进行自动装配</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Cutomer的属性person的类型为Person，Spirng会将Person类型通过setter方法进行自动装配--&gt;</span></span><br><span class="line">&lt; bean&gt; id=“cutomer” class=“com.xxx.xxx.Cutomer” autowire=“byType”/&gt;</span><br><span class="line">&lt; bean&gt; id=“person” class=“com.xxx.xxx.Person”/&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>constructor-类似byType，不过是应用于构造器的参数。如果一个bean与构造器参数的类型形<br>同，则进行自动装配，否则导致异常</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Cutomer构造函数的参数person的类型为Person，Spirng会将Person类型通过构造方法进行自动装配--&gt;</span></span><br><span class="line">&lt; bean&gt; id=“cutomer” class=“com.xxx.xxx.Cutomer” autowire=“construtor”/&gt;</span><br><span class="line">&lt; bean&gt; id=“person” class=“com.xxx.xxx.Person”/&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>autodetect-如果有默认的构造器，则通过constructor方式进行自动装配，否则使用byType方式 进行自动装配</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--如果有默认的构造器，则通过constructor方式进行自动装配，否则使用byType方式进行自动装配--&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="9-Spring-Boot、SpringMVC和Spring有什么区别？"><a href="#9-Spring-Boot、SpringMVC和Spring有什么区别？" class="headerlink" title="9.Spring Boot、SpringMVC和Spring有什么区别？"></a>9.Spring Boot、SpringMVC和Spring有什么区别？</h3><p><strong>Spring</strong>是一个IOC容器，用来管理Bean,使用依赖注入实现控制反转，可以很方便的整合各种框架，提供AOP机制弥补OOP的代码重复问题，更方便将不同方法中的共同处理抽取成切面，自动注入给方法执行，比如日志、异常等</p>
<p><strong>SpringMvc</strong>是spring对web框架的一个解决方案，提供了一个总的前端控制器Servlet，用来接受请求，然后定义了一套路由策略（url到handle的映射）及适配执行handle，将handle结果使用视图解析技术生成视图展现给前端</p>
<p><strong>SpringBoot</strong>是Spring提供的一个快速开发工具包，让程序员更方便、更快速的开发spring + springmvc应用，简化了配置（约定了默认配置），整合了一系列的解决方案（starter机制）,redis、mongodb、es可以开箱即用</p>
<h3 id="10-SpringMVC的工作流程"><a href="#10-SpringMVC的工作流程" class="headerlink" title="10.SpringMVC的工作流程"></a>10.SpringMVC的工作流程</h3><ol>
<li>用户发送请求到前端控制器DispatcherServlet</li>
<li>DispatcherServlet收到请求调用HandlerMapping处理器映射器</li>
<li>处理器映射器找到具体的处理器（可以根据xml配置、注解进行查找）,生成处理器及处理器拦截器（如果有则生成）一并返回给DispatcherServlet</li>
<li>DispatcherServlet调用HandlerAdapter处理器适配器</li>
<li>HandlerAdapter调用具体的处理器（controller，也叫后端控制器）</li>
<li>Controller执行完成返回ModelAndView</li>
<li>HandlerAdapter将Controller执行结果ModelAndView返回给DispatcherServlet</li>
<li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</li>
<li>ViewReslover解析后返回具体view</li>
<li>DispatcherServlet根据view进行渲染视图（即将模型数据填充到视图中）</li>
<li>DispatcherServlet响应给用户</li>
</ol>
<p><img src="/pictures/image-20230911141826287.png" alt="image-20230911141826287"></p>
<h3 id="11-SpringMvc中的九大组件"><a href="#11-SpringMvc中的九大组件" class="headerlink" title="11.SpringMvc中的九大组件"></a>11.SpringMvc中的九大组件</h3><p>Handler是用来干活的工具；HandlerMapping用于根据需要干的活找到相应的工具；HandlerAdapter是使用工具干活的人</p>
<ol>
<li><p><strong>HandlerMapping</strong>是用来查找Handler的。在SpringMVC中会有很多请求，每个请求都需要一个Handler处理，具体接收到一个请求之后使用哪个Handler进行处理呢？这就是HandlerMapping需要做的事。</p>
</li>
<li><p><strong>HandlerAdapter</strong>,从名字上看，它就是一个适配器。因为SpringMVC中的Handler可以是任意的形式，只要能处理请求就ok，但是Servlet需要的处理方法的结构却是固定的，都是以request和response为参数的方法。如何让固定的Servlet处理方法调用灵活的Handler来进行处理呢？这就是HandlerAdapter要做的事情。</p>
</li>
<li><p><strong>HandlerExceptionResolver</strong>其它组件都是用来干活的。在干活的过程中难免会出现问题，出问题后怎么办呢？这就需要有一个专门的角色对异常情况进行处理，在SpringMVC中就是HandlerExceptionResolver。具体来说，此组件的作用是根据异常设置ModelAndView，之后再交给render方法进行渲染。</p>
</li>
<li><p><strong>ViewResolverViewResolver</strong>用来将String类型的视图名和Locale解析为View类型的视图。View是用来渲染页面的，也就是将程序返回的参数填入模板里，生成html（也可能是其它类型）文件。这里就有两个关键问题：使用哪个模板？用什么技术（规则）填入参数？这其实是ViewResolver主要要做的工作，ViewResolver需要找到渲染所用的模板和所用的技术（也就是视图的类型）进行渲染，具体的渲染过程则交由不同的视图自己完成。</p>
</li>
<li><p><strong>RequestToViewNameTranslatorViewName</strong>是根据ViewName查找View，但有的Handler处理完后并没有设置View也没有设置ViewName，这时就需要从request获取ViewName了，如何从request中获取ViewName就是RequestToViewNameTranslator要做的事情了。RequestToViewNameTranslator在Spring MVC容器里只可以配置一个，所以所有request到ViewName的转换规则都要在一个Translator里面全部实现。</p>
</li>
<li><p><strong>LocaleResolver</strong>解析视图需要两个参数：一是视图名，另一个是Locale。视图名是处理器返回的，Locale是从哪里来的？这就是LocaleResolver要做的事情。LocaleResolver用于从request解析出Locale，Locale就是zh-cn之类，表示一个区域，有了这个就可以对不同区域的用户显示不同的结果。SpringMVC主要有两个地方用到了Locale：一是ViewResolver视图解析的时候；二是用到国际化资源或者主题的时候。</p>
</li>
<li><p><strong>ThemeResolver</strong>用于解析主题。SpringMVC中一个主题对应一个properties文件，里面存放着跟当前主题相关的所有资源、如图片、css样式等。SpringMVC的主题也支持国际化，同一个主题不同区域也可以显示不同的风格。SpringMVC中跟主题相关的类有 ThemeResolver、ThemeSource和Theme。主题是通过一系列资源来具体体现的，要得到一个主题的资源，首先要得到资源的名称，这是ThemeResolver的工作。然后通过主题名称找到对应的主题（可以理解为一个配置）文件，这是ThemeSource的工作。最后从主题中获取资源就可以了。</p>
</li>
<li><p><strong>MultipartResolver</strong>用于处理上传请求。处理方法是将普通的request包装成MultipartHttpServletRequest，后者可以直接调用getFile方法获取File，如果上传多个文件，还可以调用getFileMap得到FileName-&gt;File结构的Map。此组件中一共有三个方法，作用分别是判断是不是上传请求，将request包装成MultipartHttpServletRequest、处理完后清理上传过程中产生的临时资源。</p>
</li>
<li><p><strong>FlashMapManager</strong>用来管理FlashMap的，FlashMap主要用在redirect中传递参数。</p>
</li>
</ol>
<h3 id="12-SpringBoot自动配置原理（简答的阐述见下面15条）"><a href="#12-SpringBoot自动配置原理（简答的阐述见下面15条）" class="headerlink" title="12.SpringBoot自动配置原理（简答的阐述见下面15条）"></a>12.SpringBoot自动配置原理（简答的阐述见下面15条）</h3><p>自动装配，简单来说就是自动把第三方组件的Bean装载到Spring IOC器里面，不需要开发人员再去写Bean的装配配置。</p>
<p>在Spring Boot应用里面，只需要在启动类加上@SpringBootApplication注解就可以实现自动装配。@SpringBootApplication是一个复合注解，真正实现自动装配的注解是@EnableAutoConfiguration。</p>
<p><img src="/pictures/image-20230911195638524.png" alt="image-20230911195638524"></p>
<h3 id="13-MyBatis的优缺点"><a href="#13-MyBatis的优缺点" class="headerlink" title="13.MyBatis的优缺点"></a>13.MyBatis的优缺点</h3><p><strong>优点：</strong></p>
<ol>
<li>基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用</li>
<li>与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接</li>
<li>很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持)</li>
<li>能够与Spring很好的集成</li>
<li>提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护</li>
</ol>
<p><strong>缺点：</strong></p>
<p>1.<br>   SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求<br>2. SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库</p>
<h3 id="14-MyBatis中-和-的区别是什么？"><a href="#14-MyBatis中-和-的区别是什么？" class="headerlink" title="14.MyBatis中#{}和${}的区别是什么？"></a>14.MyBatis中#{}和${}的区别是什么？</h3><ol>
<li>功能不同：${} 是直接替换，而 #{} 是预处理</li>
<li>使用场景不同：普通参数使用 #{}，如果传递的是 SQL 命令或 SQL 关键字，需要使用 ${}，但在使用前一定要做好安全验证</li>
<li>安全性不同：使用 ${} 存在安全问题（SQL注入），而 #{} 则不存在安全问题</li>
</ol>
<h3 id="15-Spring-Boot自动装配的过程"><a href="#15-Spring-Boot自动装配的过程" class="headerlink" title="15.Spring Boot自动装配的过程"></a>15.Spring Boot自动装配的过程</h3><p><img src="/pictures/image-20230921145126572.png" alt="image-20230921145126572"></p>
<p><strong>整个自动装配的过程是</strong>：Spring Boot通过@EnableAutoConfiguration注解开启自动配置，加载spring.factories中注册的各AutoConfiguration类，当某个AutoConfiguration类满足其注解@Conditional指定的生效条件（Starters提供的依赖、配置或Spring容器中是否存在某个Bean等）时，实例化该AutoConfiguration类中定义的Bean（组件等），并注入Spring容器，就可以完成依赖框架的自动配置。</p>
<h2 id="二-Mysql相关面试题"><a href="#二-Mysql相关面试题" class="headerlink" title="二.Mysql相关面试题"></a>二.Mysql相关面试题</h2><h3 id="1-存储引擎InnoDB-与MyISAM-的区别"><a href="#1-存储引擎InnoDB-与MyISAM-的区别" class="headerlink" title="1.存储引擎InnoDB 与MyISAM 的区别"></a>1.存储引擎InnoDB 与MyISAM 的区别</h3><ol>
<li>数据存储的方式不同，MyISAM中的数据和索引是分开存储的，而InnoDB是把索引和数据存储在同一个文件里面</li>
<li>对于事务的支持不同，MyISAM不支持事务，而InnoDB支持ACID特性的事务处理</li>
<li>对于锁的支持不同，MyISAM只支持表锁，而InnoDB可以根据不同的情况，支持行锁，表锁，间隙锁，临键锁</li>
<li>MyISAM不支持外键，InnoDB支持外键因此基于这些特性，我们在实际应用中，可以根据不同的场景来选择合适的存储引擎</li>
<li>比如如果需要支持事务，那必须要选择InnoDB。如果大部分的表操作都是查询，可以选择MyISAM</li>
</ol>
<h3 id="2-索引的基本原理"><a href="#2-索引的基本原理" class="headerlink" title="2.索引的基本原理"></a>2.索引的基本原理</h3><p>原理：把无序的数据变成有序的查询</p>
<ol>
<li>把创建了索引的列的内容进行排序</li>
<li>对排序结果生成倒排表</li>
<li>在倒排表内容上拼上数据地址链</li>
<li>在查询的时候，先拿到倒排表的内容，再取出数据地址链，从而拿到数据</li>
</ol>
<h3 id="3-索引失效的场景"><a href="#3-索引失效的场景" class="headerlink" title="3.索引失效的场景"></a>3.索引失效的场景</h3><ol>
<li>索引在使用的时候没有遵循最左匹配法则.</li>
<li>模糊查询，如果%号在前面也会导致索引失效。</li>
<li>在添加索引的字段上进行了运算操作或者类型转换也都会导致索引失效。</li>
<li>如果使用了复合索引，中间使用了范围查询，右边的条件索引也会失效</li>
<li>查询的时候发生了类型转换，在查询的时候做了运算的操作和模糊查询也会导致索引失效</li>
</ol>
<h3 id="4-事务的隔离级别有哪些？MySQL-的默认隔离级别是什么？"><a href="#4-事务的隔离级别有哪些？MySQL-的默认隔离级别是什么？" class="headerlink" title="4.事务的隔离级别有哪些？MySQL 的默认隔离级别是什么？"></a>4.事务的隔离级别有哪些？MySQL 的默认隔离级别是什么？</h3><p>读未提交（Read Uncommitted）可能读到其他事务未提交的数据，也叫做脏读<br>读已提交（Read Committed）两次读取结果不一致，叫做不可重复读<br>可重复读（Repeatable Read）是mysql默认的隔离级别，每次读取的结果都一样，当时可能产生幻读<br>串行化（Serializable）一般是不会使用的，他给每一行读取的数据加锁，会导致大量超时和锁竞争的问题<br>Mysql 默认的事务隔离级别是可重复读(Repeatable Read)</p>
<h3 id="5-事务的基本特性"><a href="#5-事务的基本特性" class="headerlink" title="5.事务的基本特性"></a>5.事务的基本特性</h3><p>事务的基本特性ACID分别是：</p>
<ol>
<li>A 原子性：一个事务的操作要么全部成功，要么全部失败</li>
<li>C 一致性：数据库从一个一致性的状态转换到另一个一致性的状态</li>
<li>I 隔离性：一个事务的修改在最终提交前，对其他事务是不可见的</li>
<li>D 持久性 一旦事务提交，所做的修改就会永远的保存到数据库中</li>
</ol>
<h3 id="6-怎么处理慢查询"><a href="#6-怎么处理慢查询" class="headerlink" title="6.怎么处理慢查询"></a>6.怎么处理慢查询</h3><p>SQL查询慢的原因</p>
<ol>
<li>查询没有命中索引</li>
<li>查询了不需要的数据列</li>
<li>数据量太大</li>
</ol>
<p>根据上面的原因给出优化的措施</p>
<ol>
<li>分析语句的执行计划，然后获得其使用索引的情况，然后修改语句或者索引，使得语句可以尽可能的命中索引</li>
<li>分析语句，是否查询了不需要的数据列</li>
<li>如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表</li>
</ol>
<h3 id="7-ACID靠什么保证的"><a href="#7-ACID靠什么保证的" class="headerlink" title="7.ACID靠什么保证的"></a>7.ACID靠什么保证的</h3><p>A 原子性由<strong>undo log日志</strong>保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql</p>
<p>C 一致性由其他的三大特性保证 程序代码要保证业务上的一致性</p>
<p>I 隔离性由<strong>MVCC</strong>来保证</p>
<p>D 持久性由<strong>内存 + redo log</strong> 来保证。Mysql修改数据同时在内存和redo log记录这次操作，宕机的时候可以从redo log恢复</p>
<h2 id="三-Redis相关面试题"><a href="#三-Redis相关面试题" class="headerlink" title="三.Redis相关面试题"></a>三.Redis相关面试题</h2><h3 id="1-Redis过期键的删除策略"><a href="#1-Redis过期键的删除策略" class="headerlink" title="1.Redis过期键的删除策略"></a>1.Redis过期键的删除策略</h3><p>redis是key-value数据库，我们可以设置redis中缓存的key的过期时间。redis的过期策略就是指当redis中缓存的key过期了，redis该如何处理。</p>
<ul>
<li><strong>惰性过期</strong>：只有当访问一个key时，才会判断该key是否已过期，过期则删除。该策略可以最大化地节省CU资源，但是对内存非常的不友好。极端地情况可能出现大量地过期key没有再次被访问，从而不被清除，占用大量内存。</li>
<li>**定期过期:**每隔一定地时间，会扫描一定数量地数据库地expires字典中一定数量地key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过定时扫描的时间间隔和每次扫描的限定功耗，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。</li>
</ul>
<p>在Redis中同时使用了这两种策略</p>
<h3 id="2-Redis的线程模型，单线程为什么快"><a href="#2-Redis的线程模型，单线程为什么快" class="headerlink" title="2.Redis的线程模型，单线程为什么快"></a>2.Redis的线程模型，单线程为什么快</h3><p>IO多路复用机制监听多个Socket</p>
<p><strong>单线程快的原因：</strong></p>
<ol>
<li>纯内存操作</li>
<li>核心是基于非阻塞的IO多路复用机制</li>
<li>单线程反而避免了多线程的频繁上下文切换带来的性能问题</li>
</ol>
<h3 id="3-缓存雪崩、缓存穿透、缓存击穿"><a href="#3-缓存雪崩、缓存穿透、缓存击穿" class="headerlink" title="3.缓存雪崩、缓存穿透、缓存击穿"></a>3.缓存雪崩、缓存穿透、缓存击穿</h3><p><strong>缓存雪崩</strong> 缓存在同一时间大面积失效，所以，后面的请求都会落在数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p>解决方案：</p>
<ol>
<li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生</li>
<li>给每一个缓存数据增加响应的缓存标记，记录缓存是否失效，如果缓存标记失效，则更新数据缓存</li>
<li>缓存预热，启动系统之前先把热点数据放在缓存中去</li>
<li>互斥锁</li>
</ol>
<p><strong>缓存穿透</strong> 缓存和数据库中都没有数据，导致所有的请求都落在数据库上，造成数据库短时间内承受大量请求</p>
<p>解决方案：</p>
<ol>
<li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;&#x3D;0的直接拦截掉</li>
<li>从缓存取不到数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短一些，如30秒（设置太长会导致正常的情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</li>
<li>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力</li>
</ol>
<p><strong>缓存击穿</strong> 缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没有读到数据，又同时去数据库取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p>
<p>解决方案：</p>
<ol>
<li>设置热点数据永不过期</li>
<li>加互斥锁</li>
</ol>
<h3 id="4-Redis的数据结构"><a href="#4-Redis的数据结构" class="headerlink" title="4.Redis的数据结构"></a>4.Redis的数据结构</h3><p>Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（无序集合）及zset(有序集合)</p>
<p><img src="/pictures/image-20230914154911197.png" alt="image-20230914154911197"></p>
<p><strong>PDF</strong></p>


	<div class="row">
    <embed src="/pdf/2023最新Java面试题全集.pdf" width="100%" height="550" type="application/pdf">
	</div>




</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="/img/3.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/loading.gif'" alt="avatar"/></div><div class="author-info__name">Jason</div><div class="author-info__description">Debug the world!</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">70</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">本网站是静态网站,更新页面资源请使用Ctrl+F5;若网站内文章对你有帮助,请使用Ctrl+D收藏该网站！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">一.Java基础面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">1.谈谈你对面向对象的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-JDK%E3%80%81JRE%E3%80%81JVM%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">2.JDK、JRE、JVM之间的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%92%8Cequals%E2%BD%85%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">3.&#x3D;&#x3D;和equals⽅法的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-String-StringBuffer-StringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">4.String,StringBuffer,StringBuilder的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">5.重载和重写的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">6.接口和抽象类的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-List%E5%92%8Cset%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">7.List和set的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-hashCode-%E4%B8%8Eequals-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">8.hashCode()与equals()之间的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-ArrayList%E5%92%8CLinkedList%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">9.ArrayList和LinkedList的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-HashMap%E5%92%8CHashTable%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">10.HashMap和HashTable的区别？底层实现是什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-ConcurrentHashMap"><span class="toc-text">11.ConcurrentHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAIOC%E5%AE%B9%E5%99%A8"><span class="toc-text">12.如何实现一个IOC容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%9F%E9%87%87%E7%94%A8%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">13.什么是字节码？采用字节码的好处是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">14.Java类加载器有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-text">15.双亲委派模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-Java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB"><span class="toc-text">16.Java中的异常体系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-GC%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6"><span class="toc-text">17.GC如何判断对象可以被回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E7%8A%B6%E6%80%81"><span class="toc-text">18.线程的生命周期，线程有哪些状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-sleep-wait-join-yield-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">19.sleep(),wait(),join(),yield()的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">20.说说你对线程安全的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">21.说说你对守护线程的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-ThreadLocal%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">22.ThreadLocal的原理和使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-ThreadLocal%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%8E%9F%E5%9B%A0%EF%BC%8C%E6%80%8E%E4%B9%88%E9%81%BF%E5%85%8D"><span class="toc-text">23.ThreadLocal内存泄漏原因，怎么避免</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E4%BA%A7%E7%94%9F%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">24.产生内存泄漏的原因有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E5%B9%B6%E5%8F%91%E3%80%81%E5%B9%B6%E8%A1%8C%E3%80%81%E4%B8%B2%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">25.并发、并行、串行的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E5%B9%B6%E5%8F%91%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-text">26.并发的三大特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F%E8%A7%A3%E9%87%8A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0%EF%BC%9F"><span class="toc-text">27.为什么用线程池？解释线程池参数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E7%AE%80%E8%BF%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-text">28.简述线程池的处理流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%88%E6%B7%BB%E5%8A%A0%E9%98%9F%E5%88%97%E8%80%8C%E4%B8%8D%E6%98%AF%E5%85%88%E5%88%9B%E5%BB%BA%E6%9C%80%E5%A4%A7%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-text">29.线程池中阻塞队列的作用？为什么是先添加队列而不是先创建最大线程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%BA%BF%E7%A8%8B%E5%A4%8D%E7%94%A8%E5%8E%9F%E7%90%86"><span class="toc-text">30.线程池中线程复用原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-Spring%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">31.Spring是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9AOP%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">32.谈谈你对AOP的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9IOC%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">33.谈谈你对IOC的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-BeanFactory%E5%92%8CApplicationContext%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">34.BeanFactory和ApplicationContext有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">35.深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-TCP%E5%92%8CUDP%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9FTCP%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%EF%BC%9F"><span class="toc-text">36.TCP和UDP有什么区别？TCP为什么是三次握手，而不是两次？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-JVM%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">37.JVM中有哪些垃圾回收算法？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E6%A1%86%E6%9E%B6%E7%AF%87%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">二.框架篇相关面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Spring-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">1.Spring Bean的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8BBean%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-text">2.Spring框架中的单例Bean是线程安全的吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Spring-Bean%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">3.Spring Bean作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-text">4.Spring框架中用到了哪些设计模式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-spring%E4%B8%AD%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%92%8C%E5%8E%9F%E7%90%86%E5%BC%8F%E4%BB%A5%E5%8F%8A%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%9F"><span class="toc-text">5.spring中事务实现方和原理式以及隔离级别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6"><span class="toc-text">6.Spring事务传播机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Spring%E4%BA%8B%E5%8A%A1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%A4%B1%E6%95%88%EF%BC%9F"><span class="toc-text">7.Spring事务什么时候会失效？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%BB%80%E4%B9%88%E6%98%AFbean%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">8.什么是bean的自动装配，有哪些方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-Spring-Boot%E3%80%81SpringMVC%E5%92%8CSpring%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">9.Spring Boot、SpringMVC和Spring有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-SpringMVC%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">10.SpringMVC的工作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-SpringMvc%E4%B8%AD%E7%9A%84%E4%B9%9D%E5%A4%A7%E7%BB%84%E4%BB%B6"><span class="toc-text">11.SpringMvc中的九大组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%EF%BC%88%E7%AE%80%E7%AD%94%E7%9A%84%E9%98%90%E8%BF%B0%E8%A7%81%E4%B8%8B%E9%9D%A215%E6%9D%A1%EF%BC%89"><span class="toc-text">12.SpringBoot自动配置原理（简答的阐述见下面15条）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-MyBatis%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">13.MyBatis的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-MyBatis%E4%B8%AD-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">14.MyBatis中#{}和${}的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-Spring-Boot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">15.Spring Boot自动装配的过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-Mysql%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">二.Mysql相关面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8EInnoDB-%E4%B8%8EMyISAM-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">1.存储引擎InnoDB 与MyISAM 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-text">2.索引的基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-text">3.索引失效的场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9FMySQL-%E7%9A%84%E9%BB%98%E8%AE%A4%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">4.事务的隔离级别有哪些？MySQL 的默认隔离级别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7"><span class="toc-text">5.事务的基本特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E6%85%A2%E6%9F%A5%E8%AF%A2"><span class="toc-text">6.怎么处理慢查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-ACID%E9%9D%A0%E4%BB%80%E4%B9%88%E4%BF%9D%E8%AF%81%E7%9A%84"><span class="toc-text">7.ACID靠什么保证的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-Redis%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">三.Redis相关面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Redis%E8%BF%87%E6%9C%9F%E9%94%AE%E7%9A%84%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="toc-text">1.Redis过期键的删除策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Redis%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%EF%BC%8C%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB"><span class="toc-text">2.Redis的线程模型，单线程为什么快</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-text">3.缓存雪崩、缓存穿透、缓存击穿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">4.Redis的数据结构</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最近更新</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/64695.html" title="项目实战-黑马头条"><img src="/img/4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="项目实战-黑马头条"/></a><div class="content"><a class="title" href="/posts/64695.html" title="项目实战-黑马头条">项目实战-黑马头条</a><time datetime="2023-09-22T14:20:46.791Z" title="更新于 2023-09-22 22:20:46">2023-09-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/32696.html" title="Blog"><img src="/img/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Blog"/></a><div class="content"><a class="title" href="/posts/32696.html" title="Blog">Blog</a><time datetime="2023-09-22T13:45:32.274Z" title="更新于 2023-09-22 21:45:32">2023-09-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/24183.html" title="任务进度"><img src="/img/3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="任务进度"/></a><div class="content"><a class="title" href="/posts/24183.html" title="任务进度">任务进度</a><time datetime="2023-09-22T09:27:13.836Z" title="更新于 2023-09-22 17:27:13">2023-09-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/8957.html" title="Linux从入门到进阶"><img src="/img/3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux从入门到进阶"/></a><div class="content"><a class="title" href="/posts/8957.html" title="Linux从入门到进阶">Linux从入门到进阶</a><time datetime="2023-09-21T19:40:52.000Z" title="更新于 2023-09-22 03:40:52">2023-09-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/29985.html" title="面试题集锦"><img src="/img/3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试题集锦"/></a><div class="content"><a class="title" href="/posts/29985.html" title="面试题集锦">面试题集锦</a><time datetime="2023-09-21T02:15:56.000Z" title="更新于 2023-09-21 10:15:56">2023-09-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><br/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/19306.html" alt=""><img width="48" height="48" src="/img/1.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-04-21</span><a class="blog-slider__title" href="posts/19306.html" alt="">Docker容器化技术</a><div class="blog-slider__text">Docker</div><a class="blog-slider__button" href="posts/19306.html" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/47003.html" alt=""><img width="48" height="48" src="/img/1.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-03-10</span><a class="blog-slider__title" href="posts/47003.html" alt="">常用正则表达式大全</a><div class="blog-slider__text">正则表达式</div><a class="blog-slider__button" href="posts/47003.html" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/20683.html" alt=""><img width="48" height="48" src="/img/3.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-06-05</span><a class="blog-slider__title" href="posts/20683.html" alt="">Linux中开发环境的搭建</a><div class="blog-slider__text">环境搭建</div><a class="blog-slider__button" href="posts/20683.html" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/63333.html" alt=""><img width="48" height="48" src="/img/3.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-06-03</span><a class="blog-slider__title" href="posts/63333.html" alt="">开发环境的搭建</a><div class="blog-slider__text">环境搭建</div><a class="blog-slider__button" href="posts/63333.html" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end --></body></html>